#!/usr/bin/env ruby

require 'gli'
require 'broadside'

include GLI::App
include Broadside::Utils

program_desc 'A command-line tool for deployment and development of docker applications.'

version Broadside::VERSION

subcommand_option_handling :normal
arguments :strict
synopsis_format :full

desc 'Configuration file to use.'
default_value 'config/broadside.conf.rb'
arg_name 'FILE'
flag [:c, :config]

def add_target_configs(subcmd)
  # Everything requires a target
  subcmd.desc 'Deployment target to use, e.g. production_web'
  subcmd.arg_name 'TARGET'
  subcmd.flag [:t, :target], type: Symbol

  subcmd.action do |global_options, options, args|
    _DeployObj = Kernel.const_get("Broadside::#{Broadside.config.type.capitalize}Deploy")
    _target = Broadside.config.targets.select { |t| t.name == options[:target] }.first
    raise "Target ':#{options[:target]}' not configured. " unless _target

    _target.load_env_vars!
    _DeployObj.new(_target, options).public_send(subcmd.name)
  end
end

# Commands like bash, ssh, and logtail require an instance
def add_instance_config(cmd)
  cmd.desc '0-based index into the array of running instances'
  cmd.default_value 0
  cmd.arg_name 'INSTANCE'
  cmd.flag [:n, :instance], type: Fixnum

  add_target_configs(cmd)
end

# GLI type coercions
accept Symbol do |val|
  val.to_sym
end
accept Array do |val|
  val.split(' ')
end
accept Fixnum do |val|
  val.to_i
end

desc 'Bootstrap your service and task definition from the configured definition.'
command :bootstrap do |bootstrap|
  bootstrap.desc 'Docker tag for application container'
  bootstrap.arg_name 'TAG'
  bootstrap.flag [:tag]

  add_target_configs(bootstrap)
end

desc 'List the targets and deployed images'
command :list_targets do |list_targets|
  list_targets.action do |global_options, options, args|
    _DeployObj = Kernel.const_get("Broadside::#{Broadside.config.type.capitalize}Deploy")
    printf("%-40s %-50s %-25s %-10s %-5s %-7s %-1s %-9s %-23s\n", 'Target', 'Container Name', 'Image', 'Version', 'CPU', 'Memory', '#', 'Status', 'Started')

    Broadside.config.targets.each do |target|
      deploy = _DeployObj.new(target)
      container_definitions = Broadside::EcsManager.get_latest_task_definition(deploy.family)[:container_definitions]
      container_definitions.each do |image|
        image_tag, version = image[:image].split(':')
        task_arns = Broadside::EcsManager.get_task_arns(target.cluster, deploy.family)
        Broadside::EcsManager.ecs.describe_tasks(cluster: target.cluster, tasks: task_arns).tasks.each_with_index do |task, i|
          printf(
            "%-40s %-50s %-25s %-10s %-5s %-7s %-1d %-9s %-23s\n",
            target.name,
            image[:name],
            image_tag,
            version,
            image[:cpu],
            image[:memory],
            i + 1,
            task.last_status,
            task.started_at.utc
          )
        end
      end
    end
  end
end

desc 'Deploy your application.'
command :deploy do |d|
  d.desc 'Deploys WITHOUT running predeploy commands'
  d.command :short do |short|
    short.desc 'Docker tag for application container'
    short.arg_name 'TAG'
    short.flag [:tag]

    add_target_configs(short)
  end

  d.desc 'Deploys WITH running predeploy commands'
  d.command :full do |full|
    full.desc 'Docker tag for application container'
    full.arg_name 'TAG'
    full.flag [:tag]

    add_target_configs(full)
  end

  d.desc 'Scales application to a given count'
  d.command :scale do |scale|
    scale.desc 'Specify a new scale for application'
    scale.arg_name 'NUM'
    scale.flag [:s, :scale], type: Fixnum

    add_target_configs(scale)
  end

  d.desc 'Rolls back n releases and deploys'
  d.command :rollback do |rollback|
    rollback.desc 'Number of releases to rollback'
    rollback.arg_name 'COUNT'
    rollback.flag [:r, :rollback], type: Fixnum

    add_target_configs(rollback)
  end
end

desc 'Gets information about what is currently deployed.'
command :status do |status|
  add_target_configs(status)
end

desc 'Creates a single instance of the application to run a command.'
command :run do |run|
  run.desc 'Docker tag for application container'
  run.arg_name 'TAG'
  run.flag [:tag]

  run.desc 'Command to run (wrap argument in quotes)'
  run.arg_name 'COMMAND'
  run.flag [:command], type: Array

  add_target_configs(run)
end

desc 'Tail the logs inside a running container.'
command :logtail do |logtail|
  logtail.desc 'Number of lines to tail'
  logtail.default_value 10
  logtail.arg_name 'TAIL_LINES'
  logtail.flag [:l, :lines], type: Fixnum

  add_instance_config(logtail)
end

desc 'Establish a secure shell on an instance running the container.'
command :ssh do |ssh|
  add_instance_config(ssh)
end

desc 'Establish a shell inside a running container.'
command :bash do |bash|
  add_instance_config(bash)
end

def call_hook(type, command)
  hook = Broadside.config.public_send(type)

  if hook.is_a?(Proc)
    hook_args =
      if command.parent.is_a?(GLI::Command)
        {
          command: command.parent.name,
          subcommand: command.name
        }
      else
        { command: command.name }
      end
    debug "Calling", type, "with args", hook_args
    hook.call(hook_args)
  end
end

pre do |global, command, options, args|
  Broadside.load_config(global[:config])
  call_hook(:prehook, command)
  true
end

post do |global, command, options, args|
  call_hook(:posthook, command)
  true
end

on_error do |exception|
  # false skips default error handling
  case exception
  when Broadside::MissingVariableError
    error exception.message, "Run your last command with --help for more information."
    false
  else
    true
  end
end

exit run(ARGV)
